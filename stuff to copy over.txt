#### App.jsx

import "./App.css";
import { useState, useEffect } from "react";
import { useDropzone } from "react-dropzone";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import { BsDownload } from "react-icons/bs";
import { ImCheckboxUnchecked, ImCheckboxChecked } from "react-icons/im";
import { RiUpload2Fill } from "react-icons/ri";
import Image from "./components/Image";

function App() {
  const [selectedFile, setSelectedFile] = useState([]);
  const [preview, setPreview] = useState([]);
  const [showPreview, setShowPreview] = useState(false);
  const [types, setTypes] = useState([
    {
      label: "twitchEmotes",
      name: "Twitch Emotes",
      sizes: [28, 56, 112],
      selected: false,
    },
    {
      label: "twitchBadges",
      name: "Twitch Badges",
      sizes: [18, 36, 72],
      selected: false,
    },
    {
      label: "discordEmotes",
      name: "Discord Emotes",
      sizes: [112],
      selected: false,
    },
    {
      label: "discordStickers",
      name: "Discord Stickers",
      sizes: [128],
      selected: false,
    },
  ]);

  useEffect(() => {
    if (selectedFile.length === 0) {
      return;
    }
    console.log("here");
    let previewArray = [];
    for (let i = 0; i < selectedFile.length; i++) {
      previewArray.push(URL.createObjectURL(selectedFile[i]));
    }

    console.log(previewArray);

    setPreview(previewArray);
    setShowPreview(true);

    // free memory when ever this component is unmounted
    return () => URL.revokeObjectURL(previewArray);
  }, [selectedFile]);

  const { getRootProps, getInputProps } = useDropzone({
    accept: "image/*",
    multiple: true,
    onDrop: (acceptedFiles) => {
      setSelectedFile((prevFiles) => [...prevFiles, ...acceptedFiles]);
    },
  });

  const resizeAndDownload = async () => {
    if (!preview) {
      alert("Please upload an Image");
      return;
    }
    let selectedTypes = types.filter((type) => type.selected);
    let resizedImages = [];
    const zip = new JSZip();
    selectedTypes.forEach((type) => {
      type.sizes.forEach((size) => {
        resizedImages = preview.map(
          (url, index) =>
            new Promise((resolve, reject) => {
              const image = new Image();
              image.onload = async () => {
                // Resize image with a canvas
                let canvas = document.createElement("canvas");
                let context = canvas.getContext("2d");

                // start with the original size
                canvas.width = image.width;
                canvas.height = image.height;
                context.drawImage(image, 0, 0, canvas.width, canvas.height);

                // incrementally scale down the image until it's the desired size
                while (canvas.width > 2 * size) {
                  canvas = getHalfScaledCanvas(canvas);
                }

                if (canvas.width > size) {
                  // final step
                  const finalCanvas = document.createElement("canvas");
                  finalCanvas.width = size;
                  finalCanvas.height = size;
                  const finalContext = finalCanvas.getContext("2d");
                  finalContext.drawImage(canvas, 0, 0, size, size);
                  canvas = finalCanvas;
                }

                canvas.toBlob((blob) => {
                  // Add image to zip file
                  zip.file(
                    `${type.name}-image-${index + 1}-${size}x${size}.png`,
                    blob
                  );
                  resolve();
                }, "image/png");
              };
              image.onerror = reject;
              image.src = url;
            })
        );
      });
    });

    // A function to produce a new canvas that's half the size of the input canvas
    function getHalfScaledCanvas(canvas) {
      const halfCanvas = document.createElement("canvas");
      halfCanvas.width = canvas.width / 2;
      halfCanvas.height = canvas.height / 2;

      halfCanvas
        .getContext("2d")
        .drawImage(canvas, 0, 0, halfCanvas.width, halfCanvas.height);

      return halfCanvas;
    }

    try {
      // Wait for all images to be added to the zip
      await Promise.all(resizedImages);

      // Generate zip file and trigger download
      const content = await zip.generateAsync({ type: "blob" });
      saveAs(content, "images.zip");
    } catch (error) {
      console.error("Failed to resize images and download zip:", error);
    }
  };

  const handleClick = (event) => {
    event.stopPropagation();
    // Add your custom function logic here...
    console.log("Image clicked!");
  };

  return (
    <div className="App-header">
      <div className="left">
        <h1>Emote / Badges Resizer</h1>
        <div className="selectContainer">
          {types.map((type, index) => (
            <>
              <input
                type="checkbox"
                id={type.label}
                name={type.label}
                value={type.label}
                onChange={(e) => {
                  let newTypes = [...types];
                  newTypes[index].selected = e.target.checked;
                  setTypes(newTypes);
                }}
                style={{ display: "none" }}
              />
              <label
                for={type.label}
                className={`selectButton ${
                  type.selected ? "selectedBorder" : "unselectedBorder"
                }`}
              >
                {type.name}{" "}
                {type.selected ? (
                  <ImCheckboxChecked color="#37b437" />
                ) : (
                  <ImCheckboxUnchecked color="#d7d7d7" />
                )}
              </label>
            </>
          ))}
        </div>
      </div>
      <div className="right">
        <button
          id="file-download"
          className="downloadButton"
          onClick={resizeAndDownload}
          disabled={!showPreview}
          style={{
            display: "flex",
            alignItems: "center",
            height: "max-content",
          }}
        >
          <BsDownload style={{ marginRight: "1rem" }} />
          <p>Download</p>
        </button>
        <div {...getRootProps()} className="uploadDialog">
          <input {...getInputProps()} />
          {showPreview ? (
            <div style={{ display: "flex", flexWrap: "wrap" }}>
              {preview.map((file, index) => (
                <>
                  <Image onClick={handleClick} file={file} />
                </>
              ))}
            </div>
          ) : (
            <div
              style={{
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <p>Drag and drop some images here, or click to select images </p>
              <RiUpload2Fill size={55} />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default App;



### Image.jsx


import { ImCross } from "react-icons/im";

const Image = ({ file, onClick }) => {
  return (
    <>
      <div className="imageContainer">
        <ImCross className="cross" onClick={onClick} />
        <img className="file" alt="emote" src={file} />
      </div>
    </>
  );
};

export default Image;
